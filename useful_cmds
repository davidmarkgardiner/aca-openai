# full name
grep -r "2023-01-02-preview" .
# regex pattern
grep -r -E "[0-9]{4}-[0-9]{2}-[0-9]{2}-preview" .

# search and replace
sed -i '' 's/2023-01-02-preview/2024-01-01/g' . # stable
sed -i '' 's/2023-01-02-preview/2024-01-02-preview/g' . # preview


#!/bin/bash

# Get the AKS credentials
az aks get-credentials --resource-group <resource-group> --name <cluster-name>

# Get all Persistent Volumes in the cluster
kubectl get pv -o json | jq -r '.items[] | select(.spec.azureDisk) | .spec.azureDisk.diskURI' | while read -r diskUri; do
    # Extract the storage account name from the disk URI
    storageAccountName=$(echo $diskUri | cut -d'/' -f3 | cut -d'.' -f1)
    echo "Storage account connected to AKS: $storageAccountName"
done

kubectl get pv -o json | jq -r '.items[] | select(.spec.csi.volumeAttributes.storageaccounts) | .spec.csi.volumeAttributes.storageaccounts'

#!/bin/bash

# Get all Persistent Volumes in the cluster
pvs=$(kubectl get pv -o json | jq -r '.items[] | select(.spec.azureDisk) | .spec.azureDisk.diskURI')

# Loop through each PV
for pv in $pvs; do
    # Run your command against the PV
    echo "Processing PV: $pv"
    # Add your command here
done


The `allowSharedKeyAccess` property in Azure Kubernetes Service (AKS) is related to Azure Storage Service. It's not a direct AKS setting, but it's used when AKS interacts with Azure Storage.

When `allowSharedKeyAccess` is set to `true`, it means that the storage account accepts authorization from Shared Key. Shared Key authorization is a method that clients can use to access Azure Storage services. It uses the account access key to sign the request.

Setting `allowSharedKeyAccess` to `false` disables Shared Key authorization for the storage account. This means that you can't use Shared Key to authorize requests to the storage account. Instead, you would need to use Azure Active Directory (Azure AD) for authorization.

This setting can enhance security by requiring Azure AD for authorization, which supports more advanced features than Shared Key, such as conditional access policies and multi-factor authentication.

However, before you set `allowSharedKeyAccess` to `false`, you should ensure that all clients that access the storage account support Azure AD authorization. If any clients only support Shared Key authorization, they won't be able to access the storage account after you disable Shared Key access.



Securing a webhook in Azure DevOps (ADO) is crucial to ensure that only authorized entities can trigger it. Here are some methods to secure a webhook:

1. **Secret Token (Password)**: A secret token can be provided when setting up the webhook. This token is included in each webhook request in the `X-Hub-Signature` header. The server can then compute the expected signature and compare it with the provided signature to verify the request.

   - Pros: Simple to implement; provides a reasonable level of security.
   - Cons: If the token is leaked, anyone can trigger the webhook; tokens need to be securely stored and rotated regularly.

2. **Service Principal Name (SPN)**: An Azure AD application (with an SPN) can be used to authenticate and authorize requests. This is more complex to set up but provides a high level of security.

   - Pros: High level of security; leverages Azure AD's security features; allows for fine-grained access control.
   - Cons: More complex to set up; requires managing an Azure AD application.

3. **IP Whitelisting**: Only allow requests from certain IP addresses to trigger the webhook. This requires knowing the IP addresses that the requests will come from in advance.

   - Pros: Simple to implement; can provide a high level of security if the IP addresses are known and controlled.
   - Cons: Not flexible; if the IP addresses change, the whitelist needs to be updated; does not protect against attacks from whitelisted IP addresses.

4. **TLS (HTTPS)**: Use HTTPS for the webhook URL to ensure that the data is encrypted in transit.

   - Pros: Protects against eavesdropping and man-in-the-middle attacks; widely supported.
   - Cons: Requires a valid SSL certificate; does not protect against attacks if the attacker has the webhook URL and secret.

5. **Request Headers**: Additional custom headers can be added to the webhook requests for further validation.

   - Pros: Adds an additional layer of security; simple to implement.
   - Cons: Similar to secret tokens, if the headers are leaked, anyone can trigger the webhook.

In general, a combination of these methods should be used to secure a webhook. For example, you could use a secret token, HTTPS, and IP whitelisting together to provide multiple layers of security. The best methods to use depend on your specific use case and security requirements.
